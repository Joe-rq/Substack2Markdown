# High Schoolers Are Vibe Coding. What Does That Mean for Software’s Future?

## Vibe coding isn’t a mistake — it’s an entropy source. The future of software will depend on how we filter, correct, and evolve it.

**Sep 27, 2025**

**Likes:** 7

Recently, I stumbled upon a group of high schoolers coding in my neighborhood library. And of course — they were vibe coding. No tests, no documentation, no linters. Just pure energy: bold, excited, chasing the thrill of making something — anything — come alive on screen. It was messy, chaotic, and full of bugs.

But here’s the real question: **is this recklessness something to eliminate, or is it the raw fuel of a new software ecosystem?** What looks like disorder may actually be the true starting point of the next paradigm in software engineering. Because the way we code doesn’t just shape our programs — **it shapes how we work, how we learn, and ultimately how our entire ecosystem evolves.**

* * *

 **Vibe Coding = Entropy Source, Not a Mistake**

 **中文：Vibe Coding 不是错误，而是熵源**

When we see high schoolers or beginners writing code without tests, without documentation, and without linters, the instinct is to dismiss it as sloppy or even dangerous. Yet this view is far too narrow, because what looks like chaos is actually **entropy — the raw fuel of evolution.**

Vibe coding produces uncertainty: most of its output will not surpass what an experienced engineer can write by hand, but occasionally it yields results that are unexpectedly elegant, efficient, or creative — far beyond what careful planning would have produced. In this sense, vibe coding does not create polished products, it generates **mutations**. And as in biology, mutations are not failures but the very material on which selection acts.

Entropy in code manifests as **volume** (many snippets, variants, and prototypes), **diversity** (different styles and redundant approaches), and **uncertainty** (some correct, some broken, many in-between). The key is not to suppress this entropy but to **harness it,** which shifts the real question from _“how do we stop vibe coding?”_ to _“how do we design systems that can channel it productively?”_ This is where AI and modern tools matter most: not as mere assistants cleaning up after human mistakes, but as **entropy filters** — filtering obvious errors, correcting messy code into reusable blocks, and selecting fragments that deserve to persist.

Under this lens, vibe coding is not a liability but a source of variation, energy, and possibility, provided the ecosystem has the right filters and governance. **The future of software engineering will embrace vibe coding: its output is not a mistake, but an entropy source — to be filtered, corrected, and transformed into enduring structure.**

* * *

 **Old Risk-Only View vs. New Entropy View**

  * Old paradigm: vibe code = sloppy mistakes, must be policed.

  * New paradigm: vibe code = entropy source, like genetic mutations — most fail, but they fuel evolution.




* * *

 **Why Manual Policing Won’t Scale**

At first glance, the obvious response to messy vibe code is simple: have more experienced developers review it. But this “manual policing” approach collapses the moment you think at scale. The **volume** of code produced by AI-assisted beginners already exceeds what any team of human reviewers can keep up with — and that gap will only widen as models become faster and more accessible. What was once a trickle of half-baked snippets has become a flood, and no number of code review checklists can dam it up.

Even if we tried, the **cost is unbearable**. Senior engineers would spend their time acting as “human linters,” correcting indentation, fixing type mismatches, and patching obvious logic gaps. That is the worst possible use of scarce talent: instead of designing architectures or protocols, they would be stuck chasing down the noise generated by the long tail of vibe coding. The result is wasted expertise, slower ecosystems, and inevitable bottlenecks.

In short, manual policing turns into a **scaling trap** : the more code that gets produced, the more people you need to check it, but the less value those people create. If the ecosystem depends on human review alone, it will stagnate under its own weight. The only viable path forward is **systemic filtering** — protocols, automated validators, AI refactoring tools, and governance mechanisms that can handle the flood at machine speed.

* * *

 **Conclusion**

The future of software engineering will embrace vibe coding: its output is not a mistake, but an entropy source — to be filtered, corrected, and transformed into enduring structure. **The real challenge is building the ecosystem that can handle this entropy.** That means creating tools and protocols that act as systemic filters.

 _to be continued…._

[![](https://substackcdn.com/image/fetch/$s_!F1-N!,w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F7ec995f8-569f-4453-aa9e-2eeff947e7e7_1024x1024.heic)](https://substackcdn.com/image/fetch/$s_!F1-N!,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F7ec995f8-569f-4453-aa9e-2eeff947e7e7_1024x1024.heic)
